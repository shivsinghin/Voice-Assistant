<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lisa - Personal Voice Agent</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        .animation-delay-100 { animation-delay: 0.1s; }
        .animation-delay-200 { animation-delay: 0.2s; }
        .animation-delay-300 { animation-delay: 0.3s; }
        .animation-delay-400 { animation-delay: 0.4s; }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate-fadeInUp {
            animation: fadeInUp 0.5s ease-out;
        }
    </style>
</head>
<body class="min-h-screen bg-black text-white overflow-hidden">
    <!-- Error Display -->
    <div id="error-display" class="hidden fixed top-4 left-4 right-4 sm:left-6 sm:right-6 p-3 sm:p-4 bg-red-500/20 border border-red-500/30 text-red-200 rounded-lg backdrop-blur-sm z-50 text-sm sm:text-base animate-fadeInUp">
    </div>

    <!-- Login Modal -->
    <div id="login-modal" class="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50">
        <div class="bg-stone-900 border border-stone-700 rounded-lg p-8 w-full max-w-md mx-4 animate-fadeInUp">
            <h2 class="text-2xl font-bold text-white mb-6 text-center">Lisa Access Portal</h2>
            <form id="login-form">
                <div class="mb-4">
                    <label for="username" class="block text-white/80 text-sm font-medium mb-2">Username</label>
                    <input 
                        type="text" 
                        id="username" 
                        name="username" 
                        required
                        class="w-full px-3 py-3 bg-stone-800 border border-stone-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent"
                        placeholder="Enter your username"
                    >
                </div>
                <div class="mb-6">
                    <label for="password" class="block text-white/80 text-sm font-medium mb-2">Password</label>
                    <input 
                        type="password" 
                        id="password" 
                        name="password" 
                        required
                        class="w-full px-3 py-3 bg-stone-800 border border-stone-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent"
                        placeholder="Enter your password"
                    >
                </div>
                <button 
                    type="submit" 
                    id="login-btn"
                    class="w-full bg-purple-600 hover:bg-purple-700 text-white font-medium py-3 px-4 rounded-lg transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-stone-900"
                >
                    Access Lisa
                </button>
            </form>
            <div id="login-error" class="hidden mt-4 p-3 bg-red-500/20 border border-red-500/30 text-red-200 rounded-lg text-sm text-center">
            </div>
        </div>
    </div>

    <!-- Main Container -->
    <div id="main-app" class="hidden min-h-screen flex flex-col items-center justify-center relative px-4 sm:px-6 lg:px-8">
        
        <!-- Logout Button -->
        <div class="absolute top-4 right-4">
            <button id="logout-btn" class="pb-1 px-3 py-0.5 bg-black border-2 border-stone-900 hover:bg-stone-800 text-stone-700 rounded-lg transition-colors duration-200 text-sm">
                Logout
            </button>
        </div>

        <!-- Connection Status Indicator -->
        <div class="absolute top-4 left-4">
            <div id="connection-indicator" class="w-2 h-2 rounded-full bg-red-700 shadow-lg"></div>
        </div>
        
        <!-- Main Content Area -->
        <div class="flex flex-col items-center justify-center flex-1 w-full max-w-4xl mx-auto">
            
            <!-- Siri-like Animation Button -->
            <div class="mb-8 sm:mb-12 md:mb-16">
                <div class="flex items-center justify-center">
                    <button id="connect-btn" class="relative focus:outline-none group disabled:cursor-not-allowed">
                        <!-- Main Container -->
                        <div id="main-container" class="relative w-24 h-24 sm:w-28 sm:h-28 md:w-32 md:h-32 lg:w-36 lg:h-36 rounded-full transition-all duration-500 cursor-pointer overflow-hidden bg-stone-700 hover:bg-stone-800 border border-stone-700 shadow-2xl">
                            
                            <!-- Speaking Animation Rings -->
                            <div id="speaking-rings" class="hidden">
                                <div class="absolute inset-0 rounded-full bg-purple-400/20 animate-ping opacity-60"></div>
                                <div class="absolute inset-2 rounded-full bg-purple-300/30 animate-ping opacity-70 animation-delay-200"></div>
                                <div class="absolute inset-4 rounded-full bg-purple-200/40 animate-ping opacity-80 animation-delay-400"></div>
                            </div>
                            
                            <!-- Listening Animation Rings -->
                            <div id="listening-rings" class="hidden">
                                <div class="absolute inset-0 rounded-full bg-blue-400/20 animate-pulse opacity-50"></div>
                                <div class="absolute inset-3 rounded-full bg-blue-300/30 animate-pulse opacity-70 animation-delay-300"></div>
                            </div>
                            
                            <!-- Icons Container -->
                            <div class="absolute inset-0 flex items-center justify-center z-10">
                                <!-- Disconnected Icon -->
                                <div id="icon-disconnected" class="flex items-center justify-center">
                                    <i data-lucide="mic-off" class="w-6 h-6 sm:w-6 sm:h-6 md:w-6 md:h-6 text-white/70"></i>
                                </div>
                                
                                <!-- Idle Icon -->
                                <div id="icon-idle" class="hidden flex items-center justify-center">
                                    <i data-lucide="mic" class="w-6 h-6 sm:w-6 sm:h-6 md:w-6 md:h-6 text-white"></i>
                                </div>
                                
                                <!-- Listening Icon -->
                                <div id="icon-listening" class="hidden flex items-center space-x-1">
                                    <div class="w-1 h-6 sm:h-6 bg-white rounded animate-pulse"></div>
                                    <div class="w-1 h-6 sm:h-6 bg-white rounded animate-pulse animation-delay-100"></div>
                                    <div class="w-1 h-6 sm:h-6 bg-white rounded animate-pulse animation-delay-200"></div>
                                    <div class="w-1 h-6 sm:h-6 bg-white rounded animate-pulse animation-delay-300"></div>
                                    <div class="w-1 h-6 sm:h-6 bg-white rounded animate-pulse animation-delay-400"></div>
                                </div>
                                
                                <!-- Speaking Icon -->
                                <div id="icon-speaking" class="hidden flex items-center justify-center">
                                    <i data-lucide="volume-2" class="w-6 h-6 sm:w-6 sm:h-6 md:w-6 md:h-6 text-white animate-pulse"></i>
                                </div>
                                
                                <!-- Connecting Icon -->
                                <div id="icon-connecting" class="hidden flex items-center justify-center">
                                    <i data-lucide="waves" class="w-6 h-6 sm:w-6 sm:h-6 md:w-6 md:h-6 text-white animate-pulse"></i>
                                </div>
                            </div>
                        </div>
                    </button>
                </div>
            </div>

            <!-- Live Transcription Display - Center of Screen -->
            <div id="live-transcript" class="hidden w-full max-w-3xl mx-auto px-4 sm:px-6">
                <div class="text-center animate-fadeInUp">
                    <div id="live-transcript-text" class="text-xl sm:text-2xl md:text-3xl font-light leading-relaxed break-words mb-3">
                    </div>
                    <div id="live-speaker-indicator" class="text-sm sm:text-base font-medium opacity-60">
                    </div>
                </div>
            </div>

            <!-- Status Messages -->
            <div id="status-area" class="text-center">
                <!-- Initial Connect Message -->
                <div id="initial-message" class="text-center text-white/60 max-w-md px-4">
                </div>

                <!-- Connecting Message -->
                <div id="connecting-message" class="hidden text-center text-white/80 max-w-md px-4">
                </div>

                <!-- Status Messages for Connected State -->
                <div id="connected-status" class="hidden text-center text-white/60 max-w-md px-4">
                    <p id="status-text" class="text-base sm:text-lg font-light">
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden Audio Element -->
    <audio id="audio-el" autoplay style="display: none;"></audio>

    <script>
        // Initialize Lucide icons
        lucide.createIcons();

        // Authentication state
        let accessToken = localStorage.getItem('lisa_access_token');

        // DOM Elements
        const errorDisplay = document.getElementById('error-display');
        const loginModal = document.getElementById('login-modal');
        const mainApp = document.getElementById('main-app');
        const loginForm = document.getElementById('login-form');
        const loginError = document.getElementById('login-error');
        const logoutBtn = document.getElementById('logout-btn');
        const connectBtn = document.getElementById('connect-btn');
        const mainContainer = document.getElementById('main-container');
        const speakingRings = document.getElementById('speaking-rings');
        const listeningRings = document.getElementById('listening-rings');
        const audioEl = document.getElementById('audio-el');
        const liveTranscript = document.getElementById('live-transcript');
        const liveTranscriptText = document.getElementById('live-transcript-text');
        const liveSpeakerIndicator = document.getElementById('live-speaker-indicator');
        const connectionIndicator = document.getElementById('connection-indicator');
        const initialMessage = document.getElementById('initial-message');
        const connectingMessage = document.getElementById('connecting-message');
        const connectedStatus = document.getElementById('connected-status');
        const statusText = document.getElementById('status-text');

        // Icons
        const iconDisconnected = document.getElementById('icon-disconnected');
        const iconIdle = document.getElementById('icon-idle');
        const iconListening = document.getElementById('icon-listening');
        const iconSpeaking = document.getElementById('icon-speaking');
        const iconConnecting = document.getElementById('icon-connecting');

        // State variables
        let connected = false;
        let connecting = false;
        let isListening = false;
        let isSpeaking = false;
        let peerConnection = null;
        let dataChannel = null;
        let currentUserMessage = null;

        // Assistant message tracking (matching Next.js version)
        let currentAssistantMessage = '';
        let assistantMessageTimeout = null;
        let currentAssistantId = '';

        // Animation state management
        function updateAnimationState() {
            const state = getAnimationState();
            
            // Hide all icons and animations
            [iconDisconnected, iconIdle, iconListening, iconSpeaking, iconConnecting].forEach(el => {
                el.classList.add('hidden');
            });
            speakingRings.classList.add('hidden');
            listeningRings.classList.add('hidden');

            // Reset container classes
            mainContainer.className = 'relative w-16 h-16 sm:w-16 sm:h-16 md:w-16 md:h-16 lg:w-16 lg:h-16 rounded-full transition-all duration-500 cursor-pointer overflow-hidden';

            // Apply state-specific styles
            switch(state) {
                case 'disconnected':
                    mainContainer.classList.add('bg-stone-700', 'hover:bg-stone-800', 'shadow-2xl');
                    iconDisconnected.classList.remove('hidden');
                    break;
                case 'connecting':
                    mainContainer.classList.add('bg-stone-700', 'shadow-2xl');
                    iconConnecting.classList.remove('hidden');
                    break;
                case 'idle':
                    mainContainer.classList.add('bg-stone-700', 'hover:bg-stone-800', 'shadow-2xl', 'shadow-white/10');
                    iconIdle.classList.remove('hidden');
                    break;
                case 'listening':
                    mainContainer.classList.add('bg-blue-500/30', 'shadow-2xl');
                    iconListening.classList.remove('hidden');
                    listeningRings.classList.remove('hidden');
                    break;
                case 'speaking':
                    mainContainer.classList.add('bg-purple-500/30', 'shadow-2xl');
                    iconSpeaking.classList.remove('hidden');
                    speakingRings.classList.remove('hidden');
                    break;
            }
        }

        function getAnimationState() {
            if (connecting) return 'connecting';
            if (isSpeaking) return 'speaking';
            if (isListening) return 'listening';
            if (connected) return 'idle';
            return 'disconnected';
        }

        function updateStatusDisplay() {
            // Hide all status messages first
            initialMessage.classList.add('hidden');
            connectingMessage.classList.add('hidden');
            connectedStatus.classList.add('hidden');

            if (!connected && !connecting) {
                initialMessage.classList.remove('hidden');
            } else if (connecting) {
                connectingMessage.classList.remove('hidden');
            } else if (connected) {
                if (isListening) {
                    connectedStatus.classList.remove('hidden');
                } else if (isSpeaking) {
                    connectedStatus.classList.remove('hidden');
                } else {
                    // Hide status when idle and connected
                    connectedStatus.classList.add('hidden');
                }
            }
        }

        function showLiveTranscript(text, speaker, isInterim = false) {
            liveTranscriptText.textContent = text;
            liveSpeakerIndicator.textContent = speaker === 'user' ? 'You' : 'Lisa';
            
            // Style based on speaker
            if (speaker === 'user') {
                liveTranscriptText.className = 'text-md sm:text-md md:text-md font-light leading-relaxed break-words mb-1 text-blue-400';
                liveSpeakerIndicator.className = 'text-sm sm:text-base font-medium opacity-60 text-blue-400';
            } else {
                liveTranscriptText.className = 'text-md sm:text-md md:text-md font-light leading-relaxed break-words mb-1 text-white';
                liveSpeakerIndicator.className = 'text-sm sm:text-base font-medium opacity-60 text-purple-400';
            }
            
            // Add blinking cursor for non-final assistant messages
            if (isInterim && speaker === 'assistant') {
                liveTranscriptText.classList.add('animate-pulse');
                liveTranscriptText.innerHTML = text + '<span class="ml-2 inline-block w-0.5 h-6 sm:h-7 bg-white animate-pulse"></span>';
            } else {
                liveTranscriptText.classList.remove('animate-pulse');
                liveTranscriptText.textContent = text;
            }
            
            liveTranscript.classList.remove('hidden');
        }

        function hideLiveTranscript() {
            liveTranscript.classList.add('hidden');
        }

        function showError(message) {
            errorDisplay.textContent = message;
            errorDisplay.classList.remove('hidden');
            setTimeout(() => {
                errorDisplay.classList.add('hidden');
            }, 5000);
        }

        function showLoginError(message) {
            loginError.textContent = message;
            loginError.classList.remove('hidden');
        }

        function hideLoginError() {
            loginError.classList.add('hidden');
        }

        // Authentication functions
        async function login(username, password) {
            try {
                const response = await fetch('/api/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ username, password }),
                });

                if (response.ok) {
                    const data = await response.json();
                    accessToken = data.access_token;
                    localStorage.setItem('lisa_access_token', accessToken);
                    showMainApp();
                    hideLoginError();
                } else {
                    const errorData = await response.json();
                    showLoginError(errorData.detail || 'Login failed');
                }
            } catch (error) {
                console.error('Login error:', error);
                showLoginError('Network error. Please try again.');
            }
        }

        async function verifyToken() {
            if (!accessToken) {
                return false;
            }

            try {
                const response = await fetch('/api/verify-token', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Content-Type': 'application/json',
                    },
                });

                return response.ok;
            } catch (error) {
                console.error('Token verification error:', error);
                return false;
            }
        }

        function logout() {
            accessToken = null;
            localStorage.removeItem('lisa_access_token');
            showLoginModal();
            // Disconnect if connected
            if (connected) {
                disconnect();
            }
        }

        function showLoginModal() {
            loginModal.classList.remove('hidden');
            mainApp.classList.add('hidden');
        }

        function showMainApp() {
            loginModal.classList.add('hidden');
            mainApp.classList.remove('hidden');
        }

        function updateConnectionIndicator(state) {
            switch(state) {
                case 'connected':
                    connectionIndicator.className = 'w-2 h-2 rounded-full bg-green-700 shadow-lg';
                    break;
                case 'connecting':
                    connectionIndicator.className = 'w-2 h-2 rounded-full bg-yellow-700 shadow-lg animate-pulse';
                    break;
                default:
                    connectionIndicator.className = 'w-2 h-2 rounded-full bg-red-700 shadow-lg';
            }
        }

        // Helper function to finalize assistant message (matching Next.js version)
        const finalizeAssistantMessage = () => {
            if (currentAssistantMessage.trim()) {
                showLiveTranscript(currentAssistantMessage.trim(), 'assistant', false);
                
                // Reset
                currentAssistantMessage = '';
                currentAssistantId = '';
            }
        };

        // Your existing WebRTC functions
        const waitForIceGatheringComplete = async (pc, timeoutMs = 2000) => {
            if (pc.iceGatheringState === 'complete') return;
            console.log("Waiting for ICE gathering to complete. Current state:", pc.iceGatheringState);
            return new Promise((resolve) => {
                let timeoutId;
                const checkState = () => {
                    console.log("icegatheringstatechange:", pc.iceGatheringState);
                    if (pc.iceGatheringState === 'complete') {
                        cleanup();
                        resolve();
                    }
                };
                const onTimeout = () => {
                    console.warn(`ICE gathering timed out after ${timeoutMs} ms.`);
                    cleanup();
                    resolve();
                };
                const cleanup = () => {
                    pc.removeEventListener('icegatheringstatechange', checkState);
                    clearTimeout(timeoutId);
                };
                pc.addEventListener('icegatheringstatechange', checkState);
                timeoutId = setTimeout(onTimeout, timeoutMs);
                checkState();
            });
        };

        const createSmallWebRTCConnection = async (audioTrack) => {
            const config = {
                iceServers: [
                    {
                        urls: [
                            "stun:stun.l.google.com:19302",
                            "stun:stun1.l.google.com:19302",
                            "stun:stun2.l.google.com:19302"
                        ]
                    }
                ]
            };
            const pc = new RTCPeerConnection(config);
            addPeerConnectionEventListeners(pc);
            pc.ontrack = e => audioEl.srcObject = e.streams[0];
            
            dataChannel = pc.createDataChannel("rtvi", { ordered: true });
            setupDataChannel(dataChannel);
            
            pc.addTransceiver(audioTrack, { direction: 'sendrecv' });
            pc.addTransceiver('video', { direction: 'sendrecv' });
            await pc.setLocalDescription(await pc.createOffer());
            await waitForIceGatheringComplete(pc);
            const offer = pc.localDescription;
            const response = await fetch('/api/offer', {
                body: JSON.stringify({ sdp: offer.sdp, type: offer.type }),
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${accessToken}`
                },
                method: 'POST',
            });
            const answer = await response.json();
            await pc.setRemoteDescription(answer);
            return pc;
        };

        const setupDataChannel = (channel) => {
            channel.onopen = () => {
                console.log("Data channel opened");
                sendRTVIMessage({
                    type: "client-ready",
                    data: {
                        version: "1.0",
                        about: {
                            library: "custom-client",
                            library_version: "1.0.0",
                            platform: "web"
                        }
                    }
                });
            };

            channel.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    handleRTVIMessage(message);
                } catch (error) {
                    console.error("Error parsing RTVI message:", error);
                }
            };

            channel.onerror = (error) => {
                console.error("Data channel error:", error);
            };

            channel.onclose = () => {
                console.log("Data channel closed");
            };
        };

        const sendRTVIMessage = (message) => {
            if (dataChannel && dataChannel.readyState === 'open') {
                const rtviMessage = {
                    id: generateId(),
                    label: "rtvi-ai",
                    ...message
                };
                dataChannel.send(JSON.stringify(rtviMessage));
                console.log("Sent RTVI message:", rtviMessage);
            }
        };

        const handleRTVIMessage = (message) => {
            console.log("Received RTVI message:", message);
            
            switch (message.type) {
                case "bot-ready":
                    console.log("Bot is ready");
                    break;
                    
                case "user-started-speaking":
                    isListening = true;
                    isSpeaking = false;
                    hideLiveTranscript(); // Clear assistant transcript when user starts speaking
                    updateAnimationState();
                    updateStatusDisplay();
                    break;
                    
                case "user-stopped-speaking":
                    isListening = false;
                    updateAnimationState();
                    updateStatusDisplay();
                    break;
                    
                case "bot-started-speaking":
                    console.log('Bot started speaking');
                    isSpeaking = true;
                    isListening = false;
                    hideLiveTranscript(); // Clear user transcript when assistant starts speaking
                    // Reset for new message (matching Next.js version)
                    currentAssistantMessage = '';
                    currentAssistantId = '';
                    if (assistantMessageTimeout) {
                        clearTimeout(assistantMessageTimeout);
                    }
                    updateAnimationState();
                    updateStatusDisplay();
                    break;
                    
                case "bot-stopped-speaking":
                    console.log('Bot stopped speaking');
                    isSpeaking = false;
                    // Immediately finalize when bot stops speaking
                    if (assistantMessageTimeout) {
                        clearTimeout(assistantMessageTimeout);
                    }
                    finalizeAssistantMessage();
                    updateAnimationState();
                    updateStatusDisplay();
                    // Clear transcript after speaking is done
                    setTimeout(() => {
                        hideLiveTranscript();
                    }, 2000);
                    break;
                    
                case "user-transcription":
                    handleUserTranscription(message.data);
                    break;
                    
                case "bot-transcription":
                    handleBotTranscription(message.data);
                    break;
                    
                // Handle bot TTS text for streaming (matching Next.js version)
                case "bot-tts-text":
                    handleBotTtsText(message.data);
                    break;
                    
                default:
                    console.log("Unhandled RTVI message type:", message.type);
            }
        };

        const handleUserTranscription = (data) => {
            console.log('User transcript:', data);
            
            if (data.text && data.text.trim() && data.final) {
                showLiveTranscript(data.text.trim(), 'user', false);
            }
        };

        const handleBotTranscription = (data) => {
            // This might be the final transcription - use it if no streaming is happening
            if (data.text && data.text.trim() && !isSpeaking) {
                showLiveTranscript(data.text.trim(), 'assistant', false);
            }
        };

        // Real-time assistant display with proper spacing (matching Next.js version)
        const handleBotTtsText = (data) => {
            console.log('Bot TTS text:', data);
            
            if (data.text && data.text.trim()) {
                // Add space before new text (except for first word) - matching Next.js logic
                const textToAdd = currentAssistantMessage ? ` ${data.text}` : data.text;
                currentAssistantMessage += textToAdd;
                
                // Clear existing timeout
                if (assistantMessageTimeout) {
                    clearTimeout(assistantMessageTimeout);
                }
                
                // Create/update the building message
                if (!currentAssistantId) {
                    currentAssistantId = `assistant-building-${Date.now()}`;
                }
                
                // Show the building transcript with streaming effect
                showLiveTranscript(currentAssistantMessage, 'assistant', true);
                
                // Set timeout to finalize the message
                assistantMessageTimeout = setTimeout(() => {
                    finalizeAssistantMessage();
                }, 1000);
            }
        };

        const generateId = () => {
            return Math.random().toString(36).substr(2, 9);
        };

        const connect = async () => {
            connecting = true;
            connectBtn.disabled = true;
            updateAnimationState();
            updateStatusDisplay();
            updateConnectionIndicator('connecting');
            
            try {
                const audioStream = await navigator.mediaDevices.getUserMedia({audio: true});
                peerConnection = await createSmallWebRTCConnection(audioStream.getAudioTracks()[0]);
            } catch (error) {
                console.error('Connection failed:', error);
                showError('Failed to connect: ' + error.message);
                _onDisconnected();
            }
        };

        const addPeerConnectionEventListeners = (pc) => {
            pc.oniceconnectionstatechange = () => {
                console.log("oniceconnectionstatechange", pc?.iceConnectionState);
            };
            
            pc.onconnectionstatechange = () => {
                console.log("onconnectionstatechange", pc?.connectionState);
                let connectionState = pc?.connectionState;
                if (connectionState === 'connected') {
                    _onConnected();
                } else if (connectionState === 'disconnected') {
                    _onDisconnected();
                }
            };
            
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log("New ICE candidate:", event.candidate);
                } else {
                    console.log("All ICE candidates have been sent.");
                }
            };
            
            pc.ondatachannel = (event) => {
                const channel = event.channel;
                console.log("Received data channel:", channel.label);
                if (channel.label === "rtvi") {
                    setupDataChannel(channel);
                    dataChannel = channel;
                }
            };
        };

        const _onConnected = () => {
            connecting = false;
            connected = true;
            connectBtn.disabled = false;
            updateAnimationState();
            updateStatusDisplay();
            updateConnectionIndicator('connected');
        };

        const _onDisconnected = () => {
            connecting = false;
            connected = false;
            isListening = false;
            isSpeaking = false;
            connectBtn.disabled = false;
            hideLiveTranscript();
            updateAnimationState();
            updateStatusDisplay();
            updateConnectionIndicator('disconnected');
        };

        const disconnect = () => {
            if (!peerConnection) return;
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            peerConnection.close();
            peerConnection = null;
            _onDisconnected();
        };

        // Event listeners
        connectBtn.addEventListener("click", async () => {
            if (!connected && !connecting) {
                await connect();
            } else {
                disconnect();
            }
        });

        // Login form event listener
        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            
            if (username && password) {
                await login(username, password);
            }
        });

        // Logout button event listener
        logoutBtn.addEventListener('click', () => {
            logout();
        });

        // Initialize authentication and app
        async function initializeApp() {
            const isTokenValid = await verifyToken();
            
            if (isTokenValid) {
                showMainApp();
            } else {
                showLoginModal();
                // Clear invalid token
                if (accessToken) {
                    localStorage.removeItem('lisa_access_token');
                    accessToken = null;
                }
            }
            
            updateAnimationState();
            updateStatusDisplay();
            updateConnectionIndicator('disconnected');
        }

        // Start the app
        initializeApp();
    </script>
</body>
</html>